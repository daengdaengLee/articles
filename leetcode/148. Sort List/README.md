# 148. Sort List

[문제 링크](https://leetcode.com/problems/sort-list/)

## 요구사항

링크드 리스트의 머리 노드가 주어질 때, 오름차순으로 정렬한 링크드 리스트의 머리 노드를 반환해라.

단방향 링크드 리스트 정의:

```java
public class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

제약:

- 링크드 리스트의 노드 개수는 `0` 이상 `5 * (10 ^ 4)` 이하이다.
- `-(10 ^ 5) <= Node.val <= (10 ^ 5)`

추가 요구사항:

- `O(n * log n)` 시간 복잡도와 `O(1)` 공간 복잡도를 가지도록 구현하라.

## 예시

Example 1:

- 입력: `head = 4 -> 2 -> 1 -> 3`
- 출력: `head = 1 -> 2 -> 3 -> 4`

Example 2:

- 입력: `head = -1 -> 5 -> 3 -> 4 -> 0`
- 출력: `head = -1 -> 0 -> 3 -> 4 -> 5`

Example 3:

- 입력: `head = null`
- 출력: `head = null`

## 아이디어

- 시간 복잡도 `O(n * log n)` 을 갖는 병합 정렬 (Merge Sort) 을 사용한다.
- 노드의 순서를 추가 메모리 공간 없이 바꿀 수 있는 연결 리스트의 특징을 이용한다.

```text
fn 해법(머리_노드):
  전체_길이 = 전체_길이_구하기(머리_노드)
  if 전체_길이 <= 1:
    return 머리_노드

  부분_길이 = 1
  while 부분_길이 < 전체_길이:
    부분_머리_꼬리 = 부분_정렬하기(머리_노드, 부분_길이)
    머리_노드 = 부분_머리_꼬리.머리_노드
    부분_꼬리_노드 = 부분_머리_꼬리.꼬리_노드
    
    while 부분_꼬리_노드.next != null: 
      부분_머리_꼬리 = 부분_정렬하기(부분_꼬리_노드.next, 부분_길이)
      부분_꼬리_노드.next = 부분_머리_꼬리.머리_노드
      부분_꼬리_노드 = 부분_머리_꼬리.꼬리_노드
      
    부분_길이 <- 2배
  
  return 머리_노드
  
fn 전체_길이_구하기(머리_노드):
  전체_길이 = 0
  while 머리_노드 != null:
    전체_길이 <- 1 증가
    머리_노드 = 머리_노드.next
  return 전체_길이
  
record 부분_머리_꼬리(머리_노드, 꼬리_노드)

fn 부분_정렬하기(머리_노드, 부분_길이):
  머리_노드 = null
  현재_노드 = null
  
  앞쪽_카운트 = 부분_길이
  뒤쪽_카운트 = 부분_길이
  
  중간_노드 = 최대N개_이후_노드_구하기(노드, 부분_길이 - 1)
  if 중간_노드.next == null:
    return 부분_머리_꼬리(노드, 중간_노드)
    
  앞쪽_노드 = 노드
  뒤쪽_노드 = 중간_노드.next
  
  while 앞쪽_카운트 > 0 이거나 뒤쪽_카운트 > 0:
    if 앞쪽_카운트 == 0:
      for 0 이상, 뒤쪽_카운트 미만:
        if 뒤쪽_노드 == null:
          break
        현재_노드.next = 뒤쪽_노드
        현재_노드 = 뒤쪽_노드
        뒤쪽_노드 = 뒤쪽_노드.next
      break
    
    if 뒤쪽_카운트 == 0 이거나 뒤쪽_노드 == null:
      for 0 이상, 앞쪽_카운트 미만:
        현재_노드.next = 앞쪽_노드
        현재_노드 = 앞쪽_노드
        앞쪽_노드 = 앞쪽_노드.next
      break
    
    if 앞쪽_노드.val <= 뒤쪽_노드.val:
      if 현재_노드 == null:
        머리_노드 = 앞쪽_노드
        현재_노드 = 앞쪽_노드 
      else:
        현재_노드.next = 앞쪽_노드
        현재_노드 = 앞쪽_노드
      앞쪽_노드 = 앞쪽_노드.next
      앞쪽_카운트 <- 1 감소
    else:
      if 현재_노드 == null:
        머리_노드 = 뒤쪽_노드
        현재_노드 = 뒤쪽_노드 
      else:
        현재_노드.next = 뒤쪽_노드
        현재_노드 = 뒤쪽_노드
      뒤쪽_노드 = 뒤쪽_노드.next
      뒤쪽_카운트 <- 1 감소

  현재_노드.next = 뒤쪽_노드
  return 부분_머리_꼬리(머리_노드, 현재_노드)

fn 최대N개_이후_노드_구하기(노드, n):
  마지막_노드 = 노드
  for 0 이상, n 미만:
    if 노드 == null:
      return 마지막_노드
    마지막_노드 = 노드
    노드 = 노드.next
  return 노드 == null 이면 마지막_노드 아니면 노드 
```

시간 복잡도:

- 바깥 루프에서 부분 길이를 2배씩 늘려가며 전체 길이에 도달할 때까지 반복하므로
  `O(log n)` 만큼 시간 복잡도를 가진다.
- 안쪽 루프에서 링크드 리스트의 맨 앞 노드에서 맨 뒤 노드까지 순회하므로
  `O(n)` 만큼 시간 복잡도를 가진다.
- 전체 시간 복잡도는 `O(n * log n)` 이다. (병합 정렬과 동일한 원리이다.)

공간 복잡도:

- 링크드 리스트의 순서 변경은 next 참조 변경으로 가능하다.
- 정렬된 리스트를 담을 별도의 컬렉션 메모리 공간이 필요 없다.
- 공간 복잡도는 `O(1)` 이다.
