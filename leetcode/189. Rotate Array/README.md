# 189. Rotate Array

- [문제 링크](https://leetcode.com/problems/rotate-array/)

## Requirements

- 정수 배열 `nums`, 음이 아닌 정수 `k` 입력
- `nums` 를 `k` 번 오른쪽으로 밀어냄
- 오른쪽 끝에서 밀려난 값은 왼쪽 처음 위치로 이동
- Optional: 풀이 방법은 최소 3개 이상 존재
- Optional: in-place with `O(1)` extra space, 즉 고정 크기 메모리만 사용

## Idea

- 편의상 `nums` 의 길이를 `l` 로 표기
- `k` 가 `l` 과 같을 때 한 바퀴 회전해서 원래대로 됨
- `k` 번 회전하나 `k` 를 `l` 로 나눈 나머지만큼 회전하나 결과는 동일함
- `k` 를 `l` 로 나눈 나머지를 `k2` 로 표기

메모리 사용을 신경쓰지 않는 가장 단순한 방법:

```text
// Pseudocode

l = 길이(nums)
k2 = k % l
부분배열1 = nums[0:l-k2] // [include:exclude]
부분배열2 = nums[l-k2:l]
return 부분배열2 + 부분배열1
```

## Implementation

```java
import java.util.Arrays;

class Solution {
    public void rotate(int[] nums, int k) {
        var l = nums.length;
        var k2 = k % l;
        if (k2 == 0) {
            return;
        }
        var part1 = Arrays.copyOfRange(nums, 0, l - k2);
        var part2 = Arrays.copyOfRange(nums, l - k2, l);
        System.arraycopy(part1, 0, nums, k2, l - k2);
        System.arraycopy(part2, 0, nums, 0, k2);
    }
}
```

## Report

Accepted

Runtime 0 ms, Beats 100%

Memory 55.4 MB, Beats 79.77%

## Idea

더 단순한 방법:

- 오른쪽으로 1칸 회전하는 함수를 만들고
- `k2` 번 실행

```text
// Pseudocode

fn 오른쪽으로1칸(nums):
  l = 길이(nums)
  마지막원소 = nums[l - 1]
  nums[0:l-1] 을 nums[1:l] 에 복사
  nums[0] = 마지막원소
  
l = 길이(nums)
k2 = k % l
for k2번:
  오른쪽으로1칸(nums)
```

## Implementation

```java
class Solution {
    public void rotate(int[] nums, int k) {
        var l = nums.length;
        var k2 = k % l;
        for (var i = 0; i < k2; i += 1) {
            step(nums);
        }
    }

    private void step(int[] nums) {
        var l = nums.length;
        var last = nums[l - 1];
        System.arraycopy(nums, 0, nums, 1, l - 1);
        nums[0] = last;
    }
}
```

## Report

Time Limit Exceeded

- 테스트 실행일 땐 통과하지만 submit 하면 시간 초과

## Idea

- 배열의 맨 뒤 `k2` 개 원소를 계속 앞쪽 `k2` 개 원소와 swap
- swap 해서 앞으로 간 원소 다음부터 다시 반복해서 swap
- 더 이상 뒤에 `k2` 개 원소가 남아있지 않으면 종료

Example:

```text
// _, ^ 표시가 swap 대상

// 처음
1   2   3   4   5   6   7


6   2   3   4   5   1   7
6   7   3   4   5   1   2
_   ^
                    _   ^

6   7   1   4   5   3   2
6   7   1   2   5   3   4
        _   ^
                    _   ^

6   7   1   2   3   5   4
6   7   1   2   3   4   5
                _   ^
                    _   ^
```

```text
// Pseudocode

l = 길이(nums)
k2 = k % l
for i 는 0 부터, i + k2 < l 인 동안, i 는 k2 씩 증가:
  for 0 <= j < k2:
    앞쪽원소위치 = i + j
    뒤쪽원소위치 = l - k2 + j
    앞쪽원소 = nums[앞쪽원소위치]
    뒤쪽원소 = nums[뒤쪽원소위치]
    nums[앞쪽원소위치] = 뒤쪽원소
    nums[뒤쪽원소위치] = 앞쪽원소
```

## Implementation

```java
class Solution {
    public void rotate(int[] nums, int k) {
        var l = nums.length;
        var k2 = k % l;
        if (k2 == 0) {
            return;
        }
        for (var i = 0; i + k2 < l; i += k2) {
            for (var j = 0; j < k2; j += 1) {
                var leftIndex = i + j;
                var rightIndex = l - k2 + j;
                var leftEl = nums[leftIndex];
                var rightEl = nums[rightIndex];
                nums[leftIndex] = rightEl;
                nums[rightIndex] = leftEl;
            }
        }
    }
}
```

## Report

Wrong Answer

```text
nums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]
k = 38
outputs  = [17,18,19,20,21,22,23,24,25,26,27,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,12]
expected = [17,18,19,20,21,22,23,24,25,26,27,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
```

코드 실행 디버깅:

```text
// 입력
k = 38
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]

l = 27
k2 = 11

i = 0; 0 + 11 < 27
[ 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]
j = 0 ~ 10
[17, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1,18,19,20,21,22,23,24,25,26,27]
[17,18, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2,19,20,21,22,23,24,25,26,27]
[17,18,19, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3,20,21,22,23,24,25,26,27]
[17,18,19,20, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4,21,22,23,24,25,26,27]
[17,18,19,20,21, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5,22,23,24,25,26,27]
[17,18,19,20,21,22, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6,23,24,25,26,27]
[17,18,19,20,21,22,23, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7,24,25,26,27]
[17,18,19,20,21,22,23,24, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8,25,26,27]
[17,18,19,20,21,22,23,24,25,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,26,27]
[17,18,19,20,21,22,23,24,25,26,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,27]
[17,18,19,20,21,22,23,24,25,26,27,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11]

i = 11; 11 + 11 < 27
[17,18,19,20,21,22,23,24,25,26,27,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11]
j = 0 ~ 10
[17,18,19,20,21,22,23,24,25,26,27, 1,13,14,15,16,12, 2, 3, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2,14,15,16,12,13, 3, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3,15,16,12,13,14, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4,16,12,13,14,15, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5,12,13,14,15,16, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6,13,14,15,16,12, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7,14,15,16,12,13, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8,15,16,12,13,14, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,16,12,13,14,15,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,12,13,14,15,16,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,13,14,15,16,12]

i = 22; 22 + 11 > 27 -> 종료
```

- swap 영역이 겹치는 경우를 고려해야 함

## Idea

- 만약 swap 영역이 겹친다면 겹치지 않는 영역으로 조정해서 swap
- `i + k2 < l` 인 동안 반복
- `j` 순회 범위 조정: `i + (k2 * 2) <= l` 이면 `k2` 아니면 `l - i - k2`
- 왼쪽은 `i` 부터 오른쪽은 `l - k2` 부터
- `i` 는 실제로 swap 한 개수만큼만 증가
- `j` 순회 범위가 조정되었다면 `k2` 는 실제 swap 한 개수만큼 차감

```text
// 입력
k = 38
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]

l = 27
k2 = 11

i = 0; 0 + 11 < 27; 0 + 11 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[ 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]
0 <= j < 11(=k2 인 11)
[17, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1,18,19,20,21,22,23,24,25,26,27]
[17,18, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2,19,20,21,22,23,24,25,26,27]
[17,18,19, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3,20,21,22,23,24,25,26,27]
[17,18,19,20, 5, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4,21,22,23,24,25,26,27]
[17,18,19,20,21, 6, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5,22,23,24,25,26,27]
[17,18,19,20,21,22, 7, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6,23,24,25,26,27]
[17,18,19,20,21,22,23, 8, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7,24,25,26,27]
[17,18,19,20,21,22,23,24, 9,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8,25,26,27]
[17,18,19,20,21,22,23,24,25,10,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,26,27]
[17,18,19,20,21,22,23,24,25,26,11,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,27]
[17,18,19,20,21,22,23,24,25,26,27,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11]

i = 11; 11 + 11 < 27; 11 + 11 * 2 > 27 (k2 * 2 개보다 적게 남음)
[17,18,19,20,21,22,23,24,25,26,27,12,13,14,15,16, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11]
0 <= j < 5(=남은 개수 16 - k2 인 11)
[17,18,19,20,21,22,23,24,25,26,27, 1,13,14,15,16,12, 2, 3, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2,14,15,16,12,13, 3, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3,15,16,12,13,14, 4, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4,16,12,13,14,15, 5, 6, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5,12,13,14,15,16, 6, 7, 8, 9,10,11]
k2 = 원래 k2 인 11 - 이번에 swap 한 5 = 6

i = 16; 16 + 6 < 27; 16 + 6 * 2 > 27 (k2 * 2 개보다 적게 남음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5,12,13,14,15,16, 6, 7, 8, 9,10,11]
0 <= j < 5(=남은 개수 11 - k2 인 6)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6,13,14,15,16,12, 7, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7,14,15,16,12,13, 8, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8,15,16,12,13,14, 9,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,16,12,13,14,15,10,11]
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,12,13,14,15,16,11]
k2 = 원래 k2 인 6 - 이번에 swap 한 5 = 1

i = 21; 21 + 1 < 27; 21 + 1 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,12,13,14,15,16,11]
0 <= j < 1(=k2 인 1)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,13,14,15,16,12]

i = 22;; 22 + 1 < 27; 22 + 1 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,13,14,15,16,12]
0 <= j < 1(=k2 인 1)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,14,15,16,13]

i = 23;; 23 + 1 < 27; 23 + 1 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,14,15,16,13]
0 <= j < 1(=k2 인 1)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,15,16,14]

i = 24;; 24 + 1 < 27; 24 + 1 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,15,16,14]
0 <= j < 1(=k2 인 1)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,16,15]

i = 25;; 25 + 1 < 27; 25 + 1 * 2 <= 27 (k2 * 2 개만큼 남아있음)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,16,15]
0 <= j < 1(=k2 인 1)
[17,18,19,20,21,22,23,24,25,26,27, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16]

i = 26;; 26 + 1 == 27; -> 종료
```

```text
// Pseudocode

l = 길이(nums)
k2 = k % l

if k2 가 0 이하면:
  return

i = 0
while i + k2 가 l 보다 작으면:
  조정필요 = i + (k2 * 2) > l
  s = 조정필요 이면 l - i - k2 아니면 k2
  for 0 <= j < s:
    앞쪽원소위치 = i + j
    뒤쪽원소위치 = l - k2 + j
    앞쪽원소 = nums[앞쪽원소위치]
    뒤쪽원소 = nums[뒤쪽원소위치]
    nums[앞쪽원소위치] = 뒤쪽원소
    nums[뒤쪽원소위치] = 앞쪽원소
  if 조정필요:
    k2 는 s 만큼 감소
  i 는 s 만틈 증가
```

## Implementation

```java
class Solution {
    public void rotate(int[] nums, int k) {
        var l = nums.length;
        var k2 = k % l;

        if (k2 == 0) {
            return;
        }

        var i = 0;
        while (i + k2 < l) {
            boolean needToUpdate = i + (k2 * 2) > l;
            var s = needToUpdate ? l - i - k2 : k2;
            for (var j = 0; j < s; j += 1) {
                var leftIndex = i + j;
                var rightIndex = l - k2 + j;
                var leftEl = nums[leftIndex];
                var rightEl = nums[rightIndex];
                nums[leftIndex] = rightEl;
                nums[rightIndex] = leftEl;
            }
            if (needToUpdate) {
                k2 -= s;
            }
            i += s;
        }
    }
}
```

## Report

Accepted

Runtime 2 ms, Beats 19.45%

- 시스템 함수를 쓰지 않고 선형 시간 복잡도가 걸리는 루프를 돌았기 때문에 느려짐

Memory 56.1 MB, Beats 30.57%

- 공간 복잠도는 고정 크기 메모리만 사용하도록 개선했지만 수치는 악화됨
- 원인 불명?

## Study

다른 사람의 솔루션 참고: 추가적인 동적 크기 메모리 사용 없이 배열 돌리는 방법

```java
public class Solution {
    public void rotate(int[] nums, int k) {
        if (nums.length <= 1) {
            return;
        }
        //step each time to move
        int step = k % nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, step - 1);
        reverse(nums, step, nums.length - 1);
    }

    //reverse int array from n to m
    public void reverse(int[] nums, int n, int m) {
        while (n < m) {
            nums[n] ^= nums[m];
            nums[m] ^= nums[n];
            nums[n] ^= nums[m];
            n++;
            m--;
        }
    }
}
```

설명:

- 기존 `k2` 가 위 코드에서는 `step`
- 먼저 전체 배열을 뒤집고 `step` 만큼 나눠보면 나눈 부분 안에서는 뒤집어져 있지만 두 부분끼리는 원하는 순서대로 정렬
- 원래 뒤쪽 `step` 개만큼 앞쪽으로 이동한 상태
- 다만 앞쪽 부분, 뒤쪽 부분이 각각 뒤집어져 있을 뿐
- 각각 부분별로 따로 뒤집으면 완료
- 간단한데 매우 효과적이라서 놀랍다!
